%"The PDF file may contain up to 25 pages of reference material, single-sided, letter or A4 size, with text and illustrations readable by a person with correctable eyesight without magnification from a distance of 1/2 meter."
\input{preamble.tex}
\begin{document}
\def\title{Universidad Icesi}
.\\[0.2cm]
\centering{\LARGE\textbf{Colombia Chinese Boek}} \\[0.5cm]
\centering{\includegraphics[width=5.5cm]{img/colombiaChinese.jpg}}
\tableofcontents\newpage

\section{Mathy Stuff}
\subsection{Binary Exponentiation}
\cppfile{mathyStuff/binaryExponentiation.cpp}
\subsection{Extended Euclidean Algorithm}
\cppfile{mathyStuff/extendedEuclideanAlgo.cpp}
\subsection{Sieve of Eratosthenes}
\cppfile{mathyStuff/sieveOfEratosthenes.cpp}
\subsection{Miller-rabin primality test}
\cppfile{mathyStuff/millerRabin.cpp}
\subsection{fermats factorization method}
\cppfile{mathyStuff/fermatsFactorizationMethod.cpp}
\subsection{Floyds algorithm}
\cppfile{mathyStuff/floydsAlgorithm.cpp}
\subsection{Brents algorithm}
\cppfile{mathyStuff/brentsAlgorithm.cpp}
\subsection{Pollards rho algorithm}
\cppfile{mathyStuff/pollardsRhoAlgorithm.cpp}
\subsection{Eulers totient Function}
\cppfile{mathyStuff/eulerTotientFunction.cpp}
\subsection{Sum of divisors}
%\cppfile{mathyStuff/eulerTotientFunction.cpp}
\subsection{Garners algorithm}
\cppfile{mathyStuff/garnersAlgorithm.cpp}
\subsection{Chinese remainder theorem}
\cppfile{mathyStuff/crt.cpp}
\subsection{Factorial modulo p}
\cppfile{mathyStuff/factorialModuloP.cpp}
\subsection{Discrete logarithm}
\cppfile{mathyStuff/discreteLogarithm.cpp}
\subsection{Discrete root}
\cppfile{mathyStuff/discreteRoot.cpp}
\subsection{Primitive root}
\cppfile{mathyStuff/primitiveRoot.cpp}
\subsection{Gray Code}
\cppfile{mathyStuff/grayCode.cpp}
\subsection{Fast fourier transform}
\cppfile{mathyStuff/fft.cpp}
\subsection{Number theoretic transform}
\cppfile{mathyStuff/ntt.cpp}
\subsection{DFT Applications}
\cppfile{mathyStuff/dftApplications.cpp}
\subsection{Matrix Exponentiation}
\cppfile{mathyStuff/matrixExponentiation.cpp}
\subsection{integration by simpsons formula}
\cppfile{mathyStuff/simpsonsFormula.cpp}
\subsection{Finding power of factorial divisor}
\cppfile{mathyStuff/powerFactorialDivisor.cpp}
\subsection{Finding the modular inverse for every number modulo m}
\cppfile{mathyStuff/modularInverseAllnumModM.cpp}
\subsection{Ternary search}
\cppfile{mathyStuff/ternarySearch.cpp}
\subsection{Ternary search on integers}
\cppfile{mathyStuff/ternarySearchInteger.cpp}
\subsection{Binary Search with doubles}
\cppfile{mathyStuff/binarySearchWithDoubles.cpp}
\subsection{Intersection of two circles}
\cppfile{mathyStuff/intersectionOfTwoCircles.cpp}
\subsection{Newton's Expansion}
\subsection{Modular inverse of 2 of any odd modulo}
\subsection{Domino tiling: nxm grid}
{
number of different tilings=$\prod_{j=1}^{\lceil{\frac{m}{2}}\rceil} \prod_{k=1}^{\lceil{\frac{n}{2}}\rceil}4({\cos^2{\frac{{\pi}j}{m+1}}}+{\cos^2{\frac{{\pi}k}{n+1}}})$
}
\subsection{Complex numbers}
\cppfile{mathyStuff/complexNumbers.cpp}

\section{Combinatorics and Probability}
\subsection{Combinations formula}
\subsection{Combinations recursive definition}
\subsection{Combinations with repetitions}
\subsection{Bellâ€™s Number}
\subsection{Catalan Numbers analytical definition}
\subsection{Catalan Numbers recursive definition}
\subsection{Catalan Numbers applications}
\cppfile{combinatoricsAndProbability/catalanNumbersApplications.txt}
\subsection{Burnsides lemma}


\section{Dynamic Programming}
\subsection{Submask enumeration}
\cppfile{dynamicProgramming/submaskEnum.cpp}
\subsection{DP convex hull optimization}
\cppfile{dynamicProgramming/DPconvexHullOptimization.cpp}
\subsection{LiChao tree}
\cppfile{dynamicProgramming/liChaoTree.cpp}
\subsection{Divide and Conquer DP}
\cppfile{dynamicProgramming/divideAndConquerDP.cpp}
\subsection{Longest Increasing Subsequence}
\cppfile{dynamicProgramming/longestIncreasingSubsequence.cpp}
\subsection{LCIS}
\cppfile{dynamicProgramming/longestCommonIncreasingSubsequence.cpp}



\section{Geometry}
\subsection{Picks theorem}
\cppfile{geometry/picksTheorem.cpp}
\subsection{Point}
\cppfile{geometry/point.cpp}
\subsection{Line}
\cppfile{geometry/line.cpp}
\subsection{Circle}
\cppfile{geometry/circle.cpp}
\subsection{Polygon}
\cppfile{geometry/polygon.cpp}
\subsection{Plane}
\cppfile{geometry/plane.cpp}
\subsection{Radial order of points}
\cppfile{geometry/radial_order.cpp}
\subsection{Convex hull}
\cppfile{geometry/convex_hull.cpp}
\subsection{Dual from planar graph}
\cppfile{geometry/planar_graph_dual.cpp}
\subsection{Halfplane intersection}
\cppfile{geometry/halfplanes.cpp}

\section{Strings}
\subsection{Suffix Automaton}
\cppfile{strings/suffixAutomaton.cpp}
\subsection{Constant Suffix Automaton}
\cppfile{strings/constantSuffixAutomaton.cpp}
\subsection{Suffix Automaton applications}
\cppfile{strings/suffixAutomatonApplications.cpp}
\subsection{Z function}
\cppfile{strings/ZFunction.cpp}
\subsection{String hashing}
\cppfile{strings/stringHashing.cpp}
\subsection{Aho-Corasick}
\cppfile{strings/ahoCorasick.cpp}
\subsection{Aho-Corasick applications}
\cppfile{strings/ahoCorasickApplications.cpp}
\subsection{Suffix Array}
\cppfile{strings/suffix_array.cpp}
\subsection{Longest Common Prefix}
\cppfile{strings/lcp.cpp}
\subsection{Manacher}
\cppfile{strings/manacher.cpp}

\section{Network Flow}
\subsection{Hopcroft algorithm}
\cppfile{networkFlow/hopcroftAlgorithm.cpp}
\subsection{Augmenting Path algorithm}
\cppfile{networkFlow/augmentingPathAlgorithm.cpp}
\subsection{Maximum flow: Push-relabel with gaps}
\cppfile{networkFlow/maxFlowPushRelabelGaps.cpp}
\subsection{Edmonds-Karp algorithm}
\cppfile{networkFlow/Edmonds-KarpAlgorithm.cpp}
\subsection{Dinics Algorithm}
\cppfile{networkFlow/DinicAlgorithm.cpp}
\subsection{Min cost flow}
\cppfile{networkFlow/MinCostFlow.cpp}
\subsection{Min cost flow from cp-algorithms}
\cppfile{networkFlow/MinCostFlow2.cpp}
\subsection{Min cost flow from marcosK}
\cppfile{networkFlow/MinCostFlow3.cpp}


\section{Graphs}
\subsection{Minimum Number of swaps to sort an array}
\cppfile{graphs/minNumberOfSwapsToSortAnArray.cpp}
\subsection{Tarjan}
\cppfile{graphs/tarjan.cpp}
\subsection{Topological Sort}
\cppfile{graphs/toposort.cpp}
\subsection{Floyd Warshall}
\cppfile{graphs/floyd_warshall.cpp}
\subsection{Dijkstra}
\cppfile{graphs/dijkstra.cpp}
\subsection{ShortestCycleUndirectedGraph}
\cppfile{graphs/ShortestCycleUndirectedUnweightedGraph.cpp}
\subsection{2-SAT}
\cppfile{graphs/tarjan_2sat.cpp}
\subsection{Tree hashing}
\cppfile{graphs/treeHashing.cpp}



\section{Data Structures For Range Queries}
\subsection{Segment Tree}
\cppfile{dataStructuresForRangeQueries/segmentTree.cpp}
\subsection{Lazy segment tree}
\cppfile{dataStructuresForRangeQueries/segment_tree_lazy.cpp}
\subsection{Iterative Segment Tree}
\cppfile{dataStructuresForRangeQueries/iterativeSegmentTree.cpp}
\subsection{Dynamic segment tree}
\cppfile{dataStructuresForRangeQueries/dynamicSegmentTree.cpp}
\subsection{Descending on the tree}
\cppfile{dataStructuresForRangeQueries/descendingSegmentTree.cpp}
\subsection{Lowest Common Ancestor}
\cppfile{dataStructuresForRangeQueries/lowestCommonAncestor.cpp}
\subsection{Mos Algorithm}
\cppfile{dataStructuresForRangeQueries/mosAlgorithm.cpp}
\subsection{Fenwick Tree}
\cppfile{dataStructuresForRangeQueries/fenwick_tree.cpp}
\subsection{Sparse Table}
\cppfile{dataStructuresForRangeQueries/sparse_table.cpp}
\subsection{Sparse Table with indexed maximums/minimums}
\cppfile{dataStructuresForRangeQueries/sparse_table_indexed_maximums.cpp}


\section{Data Structures in C++}
\subsection{Tree (Ordered Set)}
\cppfile{dataStructuresInCPP/TreeOrderedSet.cpp}
\subsection{Union Find}
\cppfile{dataStructuresInCPP/unionFind.cpp}
\subsection{Hash of a pair}
\cppfile{dataStructuresInCPP/hashPair.cpp}


\section{Appendix}
\subsection{Template}
\cppfile{appendix/template.cpp}
\subsection{Getline}
\cppfile{appendix/getline.cpp}
\subsection{Set custom comparator}
\cppfile{appendix/setCustomComparator.cpp}
\subsection{ToUpperCase}
\cppfile{appendix/toUpperCase.cpp}



\end{document}

